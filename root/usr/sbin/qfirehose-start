#!/bin/sh

# QFirehose 启动脚本
# 上游 v1.4.17 已内置 zip/7z 解压功能，可直接传入压缩包路径
#
# 日志实时性说明：
#   qfirehose 的 dbg_time() 宏在每次 fprintf(stdout) 后都调用了 fflush(stdout)，
#   因此只要 stdout 直接重定向到文件（不经过管道/tee），每条日志都会立即写入磁盘。
#   不使用 -l 参数，因为 -l 写入的 loghandler 没有 fflush，反而有缓冲延迟。
#   前端 buildArgs() 也不应传 -l 参数。

LOG_DIR="/tmp/qfirehose_log"

# 确保目录存在
mkdir -p /tmp/qfirehoseupload
mkdir -p "$LOG_DIR"

# 生成带时间戳的日志文件名
timestamp=$(date +%Y%m%d_%H%M%S)
log_file="$LOG_DIR/qfirehose_${timestamp}.log"
pid_file="$LOG_DIR/pid"
status_file="$LOG_DIR/status"

# 创建符号链接指向最新的日志文件
ln -sf "$log_file" "$LOG_DIR/current.log"

# 初始化状态
echo "flashing" > "$status_file"

# 检查 qfirehose 是否可执行
if [ ! -x /usr/bin/qfirehose ]; then
    echo "Error: qfirehose not found or not executable" > "$log_file"
    echo "failed" > "$status_file"
    exit 1
fi

# 记录执行命令
echo "QFirehose start at $(date)" > "$log_file"
echo "Command: /usr/bin/qfirehose $*" >> "$log_file"
echo "---" >> "$log_file"

# 启动 qfirehose 并将其放入后台运行
# stdout 直接重定向到文件（非管道），利用 qfirehose 内部的 fflush(stdout) 实现实时写入
# stderr 也合并到 stdout，确保错误信息不丢失
(
    /usr/bin/qfirehose "$@" >> "$log_file" 2>&1
    ret=$?
    # 通过退出码和日志关键字双重判断结果
    if [ "$ret" = "0" ] && grep -q "Upgrade module successfully" "$log_file" 2>/dev/null; then
        echo "completed" > "$status_file"
    else
        echo "failed" > "$status_file"
    fi
) &
echo $! > "$pid_file"
